# AI00-MEM: ä¸ªäººAIåŠ©æ‰‹è®°å¿†ç³»ç»Ÿ

[![Rust](https://img.shields.io/badge/rust-1.70+-orange.svg)](https://www.rust-lang.org)
[![License](https://img.shields.io/badge/license-MIT-blue.svg)](LICENSE)
[![Docs](https://img.shields.io/badge/docs-latest-brightgreen.svg)](https://github.com/Ai00-X/ai00-mem)
[![GitHub](https://img.shields.io/badge/github-repo-blue.svg)](https://github.com/Ai00-X/ai00-mem)

ä¸€ä¸ªåŸºäºA-Memå’ŒHippoRAGè®ºæ–‡è®¾è®¡çš„é«˜çº§è®°å¿†ç³»ç»Ÿï¼Œä¸ºä¸ªäººAIåŠ©æ‰‹æä¾›æ™ºèƒ½çš„è®°å¿†å­˜å‚¨ã€æ£€ç´¢å’Œå­¦ä¹ èƒ½åŠ›ã€‚

## ğŸŒŸ æ ¸å¿ƒç‰¹æ€§

### ğŸ§  æ™ºèƒ½è®°å¿†ç®¡ç†
- **åŠ¨æ€è®°å¿†ç»„ç»‡**: åŸºäºZettelkastenæ–¹æ³•çš„è®°å¿†ç½‘ç»œ
- **å¤šç±»å‹è®°å¿†**: æ”¯æŒçŸ¥è¯†ã€äº‹ä»¶ã€ä»»åŠ¡ã€å¯¹è¯ç­‰å¤šç§è®°å¿†ç±»å‹
- **è‡ªåŠ¨è¿æ¥å‘ç°**: æ™ºèƒ½è¯†åˆ«è®°å¿†é—´çš„è¯­ä¹‰ã€æ—¶é—´ã€å› æœå…³ç³»
- **è®°å¿†æ¼”åŒ–**: æ ¹æ®è®¿é—®æ¨¡å¼å’Œç”¨æˆ·åé¦ˆåŠ¨æ€è°ƒæ•´è®°å¿†é‡è¦æ€§

### ğŸ” å…ˆè¿›æ£€ç´¢ç®—æ³•
- **HippoRAGæ£€ç´¢**: ç¥ç»ç”Ÿç‰©å­¦å¯å‘çš„æ£€ç´¢ç®—æ³•
- **ä¸ªæ€§åŒ–PageRank**: åŸºäºç”¨æˆ·åå¥½çš„ä¸ªæ€§åŒ–æ’åº
- **å¤šæ¨¡æ€æ£€ç´¢**: è¯­ä¹‰ã€ç»“æ„åŒ–ã€æ—¶é—´ã€æ··åˆæ£€ç´¢
- **ä¸Šä¸‹æ–‡æ„ŸçŸ¥**: è€ƒè™‘ç”¨æˆ·çŠ¶æ€ã€è®¾å¤‡ã€æ—¶é—´ç­‰ä¸Šä¸‹æ–‡ä¿¡æ¯

### ğŸ¯ è‡ªé€‚åº”å­¦ä¹ 
- **ç”¨æˆ·åå¥½å­¦ä¹ **: è‡ªåŠ¨å­¦ä¹ ç”¨æˆ·çš„æŸ¥è¯¢å’Œåé¦ˆæ¨¡å¼
- **é‡è¦æ€§è°ƒæ•´**: åŸºäºè®¿é—®é¢‘ç‡å’Œåé¦ˆåŠ¨æ€è°ƒæ•´è®°å¿†é‡è¦æ€§
- **è¿æ¥æ¼”åŒ–**: è‡ªåŠ¨å¼ºåŒ–æˆ–å¼±åŒ–è®°å¿†é—´çš„è¿æ¥
- **æ¨¡å¼æ£€æµ‹**: è¯†åˆ«ç”¨æˆ·è¡Œä¸ºå’Œè®°å¿†è®¿é—®æ¨¡å¼

### âš¡ é«˜æ€§èƒ½è®¾è®¡
- **å¼‚æ­¥å¤„ç†**: å…¨å¼‚æ­¥æ¶æ„ï¼Œæ”¯æŒé«˜å¹¶å‘
- **æ™ºèƒ½ç¼“å­˜**: å¤šå±‚ç¼“å­˜ç­–ç•¥ï¼Œä¼˜åŒ–æ£€ç´¢æ€§èƒ½
- **æ‰¹å¤„ç†**: æ”¯æŒæ‰¹é‡æ“ä½œå’Œå¹¶è¡Œå¤„ç†
- **å†…å­˜ä¼˜åŒ–**: é«˜æ•ˆçš„å‘é‡å­˜å‚¨å’Œå‹ç¼©ç®—æ³•

### ğŸŒ å¤šè¯­è¨€å‘é‡åµŒå…¥
- **å†…ç½®å¤šè¯­è¨€æ”¯æŒ**: åŸç”Ÿæ”¯æŒä¸­æ–‡ã€è‹±æ–‡ã€æ—¥æ–‡ã€éŸ©æ–‡ç­‰å¤šç§è¯­è¨€
- **Model2Vecé›†æˆ**: åˆ©ç”¨model2vec-rså®ç°é«˜æ•ˆçš„å¤šè¯­è¨€åµŒå…¥
- **è·¨è¯­è¨€æ£€ç´¢**: æ— ç¼è·¨è¯­è¨€æœç´¢è®°å¿†å†…å®¹
- **è¯­è¨€æ„ŸçŸ¥å¤„ç†**: è‡ªåŠ¨è¯­è¨€æ£€æµ‹å’Œä¼˜åŒ–ç¼–ç 
- **è½»é‡çº§æ¨¡å‹**: ä¸ºèµ„æºå—é™ç¯å¢ƒä¼˜åŒ–çš„åµŒå…¥æ¨¡å‹

### ğŸ”§ çµæ´»é…ç½®
- **æ•°æ®åº“æ”¯æŒ**: ä¸“æ³¨äºSQLiteï¼Œè½»é‡çº§ä¸”åŠŸèƒ½å¼ºå¤§
- **æ¨¡å—åŒ–è®¾è®¡**: å¯æ’æ‹”çš„ç»„ä»¶æ¶æ„
- **ä»£ç é…ç½®**: æ”¯æŒä»£ç æ–¹å¼é…ç½®
- **æ‰©å±•æ€§**: æ˜“äºæ‰©å±•æ–°çš„æ£€ç´¢ç®—æ³•å’Œå­¦ä¹ ç­–ç•¥

## ğŸš€ å¿«é€Ÿå¼€å§‹

### å®‰è£…

åœ¨ `Cargo.toml` ä¸­æ·»åŠ ä¾èµ–ï¼š

```toml
[dependencies]
ai00-mem = "0.1.0"
tokio = { version = "1.0", features = ["full"] }
```

### åŸºæœ¬ä½¿ç”¨

```rust
use ai00_mem::{MemoryManager, Config, CreateMemoryRequest, Context, Query};
use std::sync::Arc;

#[tokio::main]
async fn main() -> Result<(), Box<dyn std::error::Error>> {
    // 1. åˆ›å»ºé…ç½®
    let mut config = Config::default();
    config.vector.similarity_threshold = 0.7;
    
    // 2. åˆ›å»ºæ•°æ®åº“è¿æ¥
    let db = Arc::new(ai00_mem::database::VectorGraphDB::new(&config).await?);
    
    // 3. åˆ›å»ºè®°å¿†ç®¡ç†å™¨
    let memory_manager = MemoryManager::new(db, config).await?;
    
    // 4. åˆ›å»ºè®°å¿†è¯·æ±‚
    let request = CreateMemoryRequest {
        content: "Rustæ˜¯ä¸€ç§ç³»ç»Ÿç¼–ç¨‹è¯­è¨€ï¼Œæ³¨é‡å®‰å…¨æ€§ã€å¹¶å‘æ€§å’Œæ€§èƒ½ã€‚".to_string(),
        context: Context {
            session_id: Some("session_001".to_string()),
            current_topic: Some("ç¼–ç¨‹è¯­è¨€".to_string()),
            ..Default::default()
        },
        attributes: None,
        force_connections: None,
    };
    
    // 5. åˆ›å»ºè®°å¿†
    let memory = memory_manager.create_memory_from_request(request).await?;
    println!("åˆ›å»ºè®°å¿†: {}", memory.id);
    
    // 6. æŸ¥è¯¢ç›¸å…³è®°å¿†
    let query = Query {
        text: "Rustç¼–ç¨‹è¯­è¨€".to_string(),
        memory_type: None,
        limit: 10,
        offset: 0,
        sort_by: ai00_mem::core::SortBy::Relevance,
        weights: Default::default(),
    };
    
    let results = memory_manager.retrieve_memories(query).await?;
    println!("æ‰¾åˆ° {} ä¸ªç›¸å…³è®°å¿†", results.len());
    
    for result in results {
        println!("- {} (ç›¸å…³æ€§: {:.2})", 
            result.memory.content, 
            result.relevance_score);
    }
    
    Ok(())
}
```

### é«˜çº§åŠŸèƒ½ç¤ºä¾‹

```rust
use ai00_mem::prelude::*;

#[tokio::main]
async fn main() -> Result<()> {
    let config = Config::default();
    let db = Arc::new(VectorGraphDB::new(config.clone()).await?);
    
    // åˆå§‹åŒ–å®Œæ•´ç³»ç»Ÿ
    let memory_manager = MemoryManager::new(db.clone(), config.clone()).await?;
    let retriever = HippoRAGRetriever::new(db.clone(), config.clone()).await?;
    let learning_engine = LearningEngine::new(db.clone(), config.clone()).await?;
    
    // åˆ›å»ºå¸¦ä¸Šä¸‹æ–‡çš„æŸ¥è¯¢
    let query = Query {
        text: "æœºå™¨å­¦ä¹ ç®—æ³•".to_string(),
        user_id: "user_123".to_string(),
        context: Some(Context {
            session_id: "session_456".to_string(),
            timestamp: Utc::now(),
            user_state: UserState::Active,
            task_context: Some("å­¦ä¹ ".to_string()),
            emotional_state: Some(EmotionalState::Curious),
            attention_level: Some(AttentionLevel::High),
            ..Default::default()
        }),
        filters: vec![
            Filter::MemoryType(MemoryType::Knowledge),
            Filter::TimeRange(Utc::now() - Duration::days(30), Utc::now()),
        ],
        max_results: 5,
        min_relevance: 0.6,
    };
    
    // ä½¿ç”¨HippoRAGæ£€ç´¢
    let results = retriever.hippocampus_retrieval(&query).await?;
    
    // è®°å½•ç”¨æˆ·åé¦ˆ
    let feedback = FeedbackRecord {
        memory_id: results[0].memory.id.clone(),
        user_id: "user_123".to_string(),
        feedback_type: FeedbackType::Explicit,
        score: 0.9,
        context: FeedbackContext {
            query: query.text.clone(),
            result_position: 0,
            session_id: "session_456".to_string(),
            device_type: Some("desktop".to_string()),
            time_of_day: 14,
            day_of_week: 1,
        },
        timestamp: Utc::now(),
    };
    
    learning_engine.record_feedback(feedback).await?;
    
    // è¿è¡Œå­¦ä¹ å¾ªç¯
    let learning_results = learning_engine.run_learning_cycle().await?;
    println!("å­¦ä¹ å¾ªç¯å®Œæˆï¼Œæ‰§è¡Œäº† {} ä¸ªä»»åŠ¡", learning_results.len());
    
    Ok(())
}
```

## ğŸ“– è¯¦ç»†æ–‡æ¡£

### æ ¸å¿ƒAPI

#### è®°å¿†ç®¡ç†å™¨

- `MemoryManager::new(db: Arc<VectorGraphDB>, config: Config) -> Result<Self>`: åˆ›å»ºæ–°çš„è®°å¿†ç®¡ç†å™¨
- `create_memory_from_request(&self, request: CreateMemoryRequest) -> Result<Memory>`: ä»è¯·æ±‚åˆ›å»ºæ–°è®°å¿†
- `retrieve_memories(&self, query: Query) -> Result<Vec<RetrievalResult>>`: æ£€ç´¢ç›¸å…³è®°å¿†
- `update_memory(&self, request: UpdateMemoryRequest) -> Result<Memory>`: æ›´æ–°è®°å¿†
- `delete_memory(&self, memory_id: &str) -> Result<()>:`: åˆ é™¤è®°å¿†
- `generate_embedding(&self, text: &str) -> Result<Vec<f32>>`: ç”Ÿæˆæ–‡æœ¬åµŒå…¥å‘é‡

#### è¯·æ±‚ç»“æ„

- `CreateMemoryRequest`: è®°å¿†åˆ›å»ºè¯·æ±‚
  - `content: String`: è®°å¿†å†…å®¹
  - `context: Context`: ä¸Šä¸‹æ–‡ä¿¡æ¯
  - `attributes: Option<MemoryAttributes>`: è®°å¿†å±æ€§ï¼ˆå¯é€‰ï¼‰
  - `force_connections: Option<Vec<MemoryId>>`: å¼ºåˆ¶è¿æ¥çš„è®°å¿†IDï¼ˆå¯é€‰ï¼‰

- `UpdateMemoryRequest`: è®°å¿†æ›´æ–°è¯·æ±‚
  - `memory_id: MemoryId`: è®°å¿†ID
  - `updates: Vec<UpdateType>`: æ›´æ–°æ“ä½œåˆ—è¡¨

## ğŸ™ è‡´è°¢

- çµæ„Ÿæ¥æºäº[A-Mem](https://arxiv.org/abs/2312.00001)å’Œ[HippoRAG](https://arxiv.org/abs/2405.14813)
- åŸºäº[Rust](https://www.rust-lang.org)å’Œ[SQLite](https://www.sqlite.org)æ„å»º
- å¤šè¯­è¨€åµŒå…¥ç”±[model2vec-rs](https://github.com/anonymous-ai/model2vec-rs)æä¾›æ”¯æŒ
- æ„Ÿè°¢å¼€æºç¤¾åŒºçš„å¯å‘å’Œæ”¯æŒ